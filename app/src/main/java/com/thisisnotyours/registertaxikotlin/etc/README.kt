package com.thisisnotyours.registertaxikotlin.etc

class README {

    //me: Scope
//    Scope : 코루틴이 실행되는 범위로, 예를 들어 코루틴 튜토리얼 글에서 많이 볼 수 있는 Globalscope는 앱 전체의 생명 주기를 따른다.
//    즉, 앱이 실행중이라면 코루틴이 계속 실행될 수 있다.
//    만약 Activity와 라이프사이클을 같이 하는 scope를 만든다면 activity가 종료되기 전까지만 실행되고,
//    액티비티가 종료되면 해당 스코프를 사용한 코루틴도 같이 종료된다.
//
//  //me: Launch
//    Launch : 비동기적으로 실행될 코드 블럭을 받아서 코루틴을 실행시키는 함수
//
//   //me: Suspend fun
//    Suspend function : 코루틴 블럭을 임시로 빠져나가는 함수. 코루틴 블럭 안에서만 호출할 수 있으며,
//    이 함수를 만나면 코루틴 블럭을 잠시 빠져나가고, 이 함수는 그대로 비동기적으로 수행된다.
//    그 후, 해당 함수의 작업이 완료되면 다시 코루틴 블럭으로 돌아와서 해당 함수의 다음부터 이어서 실행된다.
//    해당 함수의 작업이 완료되기 전까지는 코루틴 블럭 안에서 다음으로 넘어가지 않는다.
//


    //me:  Scope 의 종류
//    GlobalScope - 특정 액티비티나 프래그먼트의 생명주기와 함께 동작해서 실행 도중 별도 생명주기 관리가 필요없다.
//                   시작부터 종료까지 실행 시간이 비교적 긴 코루틴의 경우에 적합하다.
//    CoroutineScope - 필요할때만 열고 완료되면 닫아주는 코루틴 스코프에 사용하기 적합하다.
//    ViewModelScope - 뷰모델 컴포넌트를 사용한다면, ViewModel 인스턴스에서 사용하기 위해 제공되는 스코프이다.
//                     GlobalScope와 비슷하게, 뷰모델 인스턴스가 소멸될 때 자동으로 소멸되고 작업도 자연스럽게 취소된다.



    //me: Dispatchers
//    Dispatcher 를 몰라서 CoroutineScope를 안쓴 것 같은 느낌도 없잖아 있다. 그래서 Dispatcher 에 대해 좀 설명하자면,
//    코루틴을 실행 때 적당한 스레드에 할당하여 실행 도중 발생하는 pause 나 resume 를 담당한다.

//    Dispatchers 종류
//    Default : CPU 를 많이 쓰는 작업에 최적화 되어있는 디스패쳐
//    IO : Input/Output 의 약자처럼 이미지 다운로드, 파일 입출력 등과 같은 입출력 작업에 최적화 되어있는 디스패쳐
//    Main : 메인이라하면 역시 UI 아니겠는가? UI 작업과 찰떡궁합인 디스패쳐
//    Unconfined : 이건 사실 좀 특이해서 참고한 설명을 그대로 적는다.
//    호출한 컨텍스트(Context)를 기본으로 사용하는 디스패쳐이다. 다만 작업이 중단된 후 다시 실행될 때 컨텍스트가 바뀌면 바뀐 컨텍스트를 따라간다.

}